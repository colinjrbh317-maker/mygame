<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hunted: House Hideout</title>
<style>
  :root{
    --bg:#0d0f12; --panel:#14181f; --text:#e9eef5; --muted:#9aa7b6; --accent:#e87a64;
    --ok:#52d386; --warn:#ffd166; --bad:#ff6b6b; --line:#263043;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1200px 600px at 50% -200px,#10151d,#0b0f14);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;border-bottom:1px solid var(--line);background:#0c1219;position:sticky;top:0;z-index:2}
  header .title{font-weight:800;letter-spacing:.5px}
  header .meta{display:flex;gap:10px;flex-wrap:wrap}
  .chip{background:#0f1620;border:1px solid var(--line);border-radius:999px;padding:6px 10px;color:var(--muted);font-size:13px}
  .chip strong{color:var(--text)}

  main{display:grid;grid-template-columns:1.4fr 1fr;gap:12px;padding:12px;height:calc(100% - 56px)}
  #board{background:#0e141c;border:1px solid var(--line);border-radius:14px;padding:12px;display:flex;flex-direction:column}
  #grid{flex:1;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:10px}
  .cell{position:relative;border:1px solid #263043;border-radius:12px;background:linear-gradient(180deg,#101722,#0c131c);display:grid;place-items:center;overflow:hidden;cursor:pointer;transition:transform .08s ease}
  .cell:hover{transform:translateY(-1px)}
  .cell.disabled{opacity:.35;filter:grayscale(40%);cursor:not-allowed}
  .cell .label{position:absolute;bottom:8px;left:8px;font-size:12px;color:#b7c5d8;background:#0d141cbb;padding:3px 6px;border-radius:6px;border:1px solid #1f2a3a}
  .you{outline:2px solid var(--ok);box-shadow:inset 0 0 0 2px #1d2a22}
  .target{animation:ping 0.9s ease-out 2}
  @keyframes ping{0%{box-shadow:0 0 0 0 rgba(232,122,100,.8)}100%{box-shadow:0 0 0 18px rgba(232,122,100,0)}}
  .boom{animation:boom .6s ease-out}
  @keyframes boom{0%{filter:none}30%{filter:brightness(2) saturate(1.3)}60%{transform:scale(1.03);filter:contrast(1.2)}100%{filter:grayscale(60%)} }
  .blast{position:absolute;inset:0;pointer-events:none;background:radial-gradient(200px 200px at var(--x,50%) var(--y,50%),rgba(255,120,80,.85),transparent 70%);mix-blend-mode:screen;opacity:0;animation:flash .5s ease-out}
  @keyframes flash{0%{opacity:.95}100%{opacity:0}}

  #side{display:grid;grid-template-rows:auto auto 1fr;gap:10px}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  button{background:#121a25;border:1px solid #2a394d;color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer}
  button.primary{background:#1a232f;border-color:#33465f}
  button.accent{background:#231311;border-color:#6d4037;color:#ffdcd4}
  button[disabled]{opacity:.5;cursor:not-allowed}

  #log{height:200px;overflow:auto;background:#0d131b;border:1px dashed #2a3648;border-radius:10px;padding:8px;font-size:13px}
  #items .item{padding:6px 8px;border:1px solid #344760;border-radius:8px;background:#101823;color:#cbd7ea;cursor:pointer}
  #items .item.used{opacity:.4;cursor:not-allowed}

  .hint{color:#a7bed6}
  .danger{color:var(--bad)}

  @media(max-width: 980px){ main{grid-template-columns:1fr} #log{height:160px} }
</style>
</head>
<body>
<header>
  <div class="title">Hunted: House Hideout</div>
  <div class="meta">
    <div class="chip">Rooms left: <strong id="roomsLeft">8</strong></div>
    <div class="chip">Round: <strong id="round">1</strong></div>
    <div class="chip">Timer: <strong id="timer">—</strong></div>
    <div class="chip">Difficulty: <strong id="diffLabel">Normal</strong></div>
    <div class="chip">Best: <strong id="best">0</strong></div>
    <div class="chip"><label><input type="checkbox" id="soundToggle" checked/> Sound</label></div>
  </div>
</header>
<main>
  <section id="board" class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div style="font-weight:700">House Map</div>
      <div class="row">
        <button id="stayBtn" class="primary">Stay</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>
    <div id="grid"></div>
  </section>

  <section id="side">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
        <div>
          <div style="font-weight:700;margin-bottom:4px">Your Turn</div>
          <div id="turnText" class="hint">Pick a starting room.</div>
        </div>
        <div class="row">
          <select id="difficulty">
            <option>Easy</option>
            <option selected>Normal</option>
            <option>Hard</option>
          </select>
          <button id="applyDiff">Apply</button>
        </div>
      </div>
      <div style="margin-top:10px">
        <div style="font-weight:700;margin-bottom:6px">Items</div>
        <div id="items" class="row"></div>
      </div>
    </div>

    <div class="panel">
      <div style="font-weight:700;margin-bottom:6px">Hints</div>
      <div id="hints" class="hint">—</div>
    </div>

    <div class="panel">
      <div style="font-weight:700;margin-bottom:6px">Round Log</div>
      <div id="log"></div>
    </div>
  </section>
</main>

<script>
/*** CONFIG ***/
const ROOM_LIST = [
  {id:'living',   name:'Living Room',  x:0,y:0},
  {id:'kitchen',  name:'Kitchen',      x:1,y:0},
  {id:'bath',     name:'Bathroom',     x:2,y:0},
  {id:'garage',   name:'Garage',       x:0,y:1},
  /* center empty */
  {id:'bed',      name:'Bedroom',      x:2,y:1},
  {id:'dining',   name:'Dining',       x:0,y:2},
  {id:'game',     name:'Game Room',    x:1,y:2},
  {id:'patio',    name:'Outside Patio',x:2,y:2},
];
const ADJ = (a,b)=> (Math.abs(a.x-b.x)+Math.abs(a.y-b.y)===1); // N/E/S/W

const DIFF = {
  'Easy':   {turnTimer:null, chainStart:Infinity, chainPct:0},
  'Normal': {turnTimer:12,    chainStart:4,       chainPct:0.05},
  'Hard':   {turnTimer:8,     chainStart:3,       chainPct:0.08}
};
const MOVE_HEAT = 0.15; // +15% weight on destination when you move
const HINT_TRUTH = 0.6; // 60% accurate

/*** STATE ***/
let state = {
  active: new Set(ROOM_LIST.map(r=>r.id)),
  player: null,
  round: 1,
  movedThisTurn: false,
  difficulty: 'Normal',
  items: { Decoy:true, Scout:true, Dash:true, Vest:false },
  weights: {},
  timer:null,
  timeLeft:null,
  best: Number(localStorage.getItem('hunted_best')||0),
};

/*** UTILS ***/
const rand = (n)=> Math.floor(Math.random()*n);
function pickWeighted(weights){
  const entries = Object.entries(weights).filter(([k,w])=>state.active.has(k));
  const sum = entries.reduce((a,[_k,w])=>a+w,0);
  let r = Math.random()*sum;
  for(const [k,w] of entries){ if((r-=w)<=0) return k; }
  return entries.at(-1)[0];
}
function neighbors(id){ const a=ROOM_LIST.find(r=>r.id===id); return ROOM_LIST.filter(b=>state.active.has(b.id) && ADJ(a,b)); }
function log(msg){ const el=document.getElementById('log'); const d=document.createElement('div'); d.textContent=msg; el.appendChild(d); el.scrollTop=el.scrollHeight; }
function setHints(text){ document.getElementById('hints').textContent=text; }
function setTurn(t){ document.getElementById('turnText').textContent=t; }

/*** AUDIO (WebAudio) ***/
let audioCtx=null; function audio(){ if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); } return audioCtx; }
function beep(freq=440, dur=0.1, type='sine', vol=0.02){ if(!document.getElementById('soundToggle').checked) return; const ctx=audio(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(ctx.destination); g.gain.value=vol; o.start(); o.stop(ctx.currentTime+dur); }
function boom(){ if(!document.getElementById('soundToggle').checked) return; const ctx=audio(); const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(120,ctx.currentTime); o.frequency.exponentialRampToValueAtTime(40,ctx.currentTime+0.5); g.gain.setValueAtTime(0.15,ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001,ctx.currentTime+0.6); o.connect(g); g.connect(ctx.destination); o.start(); o.stop(ctx.currentTime+0.65); }
function heartbeat(){ if(!document.getElementById('soundToggle').checked) return; beep(90,0.07,'sine',0.03); setTimeout(()=>beep(90,0.06,'sine',0.02),140); }

/*** DOM ***/
const grid = document.getElementById('grid');
function buildGrid(){
  grid.innerHTML='';
  // 3x3 grid with center hole
  for(let y=0;y<3;y++){
    for(let x=0;x<3;x++){
      const room = ROOM_LIST.find(r=>r.x===x && r.y===y);
      const cell = document.createElement('div');
      cell.className='cell';
      if(!room){ cell.style.visibility='hidden'; grid.appendChild(cell); continue; }
      cell.id='cell-'+room.id;
      cell.addEventListener('click',()=>onCellClick(room.id));
      const lab=document.createElement('div'); lab.className='label'; lab.textContent=room.name; cell.appendChild(lab);
      grid.appendChild(cell);
      drawCell(room.id);
    }
  }
}
function drawCell(id){
  const cell = document.getElementById('cell-'+id);
  const alive = state.active.has(id);
  cell.classList.toggle('disabled', !alive);
  cell.classList.toggle('you', state.player===id && alive);
}
function refreshAll(){ ROOM_LIST.forEach(r=>drawCell(r.id)); document.getElementById('roomsLeft').textContent=state.active.size; document.getElementById('round').textContent=state.round; document.getElementById('diffLabel').textContent=state.difficulty; document.getElementById('best').textContent=state.best; }

/*** TIMER ***/
function startTimer(){ clearInterval(state.timer); const tt=DIFF[state.difficulty].turnTimer; document.getElementById('timer').textContent = tt?tt:'∞'; if(!tt){ state.timeLeft=null; return; } state.timeLeft=tt; document.getElementById('timer').textContent=state.timeLeft; state.timer=setInterval(()=>{ state.timeLeft--; document.getElementById('timer').textContent=state.timeLeft; if(state.timeLeft<=3) heartbeat(); if(state.timeLeft<=0){ clearInterval(state.timer); autoStay(); } },1000); }
function autoStay(){ setTurn('Time up — you stayed.'); resolvePlayerChoice(state.player,false); }

/*** GAME FLOW ***/
function reset(){ state.active=new Set(ROOM_LIST.map(r=>r.id)); state.player=null; state.round=1; state.movedThisTurn=false; state.items={Decoy:true,Scout:true,Dash:true,Vest:false}; state.weights={}; setHints('—'); document.getElementById('items').innerHTML=''; buildItems(); buildGrid(); refreshAll(); setTurn('Pick a starting room.'); startTimer(); log('— New game —'); }

function onCellClick(id){
  if(!state.active.has(id)) return;
  if(state.player===null){ state.player=id; setTurn('Stay or move to an adjacent room. Use an item if needed.'); refreshAll(); return; }
  // movement phase
  const adj = neighbors(state.player).map(r=>r.id);
  if(!adj.includes(id)){ setTurn('You can only move to adjacent rooms.'); return; }
  state.player=id; state.movedThisTurn=true; refreshAll(); setTurn(`Moved to ${ROOM_LIST.find(r=>r.id===id).name}. Choose Stay or end turn.`); }

document.getElementById('stayBtn').onclick=()=>{ if(state.player===null) { setTurn('Pick a starting room first.'); return; } resolvePlayerChoice(state.player, state.movedThisTurn); };

document.getElementById('resetBtn').onclick=reset;

document.getElementById('applyDiff').onclick=()=>{ state.difficulty=document.getElementById('difficulty').value; startTimer(); refreshAll(); };

function resolvePlayerChoice(dest, moved){ clearInterval(state.timer); // compute weights
  state.weights={}; state.active.forEach(id=> state.weights[id]=1);
  if(moved) state.weights[dest]+=MOVE_HEAT*state.weights[dest];
  // Scout item effect: if used this round, we already showed; otherwise generate hints
  genHints();
  // Murderer selects target
  const target = pickWeighted(state.weights);
  explode(target);
  // Chain chance
  const cfg=DIFF[state.difficulty];
  if(state.round>=cfg.chainStart && Math.random()<cfg.chainPct){
    const adj = neighbors(target).map(r=>r.id).filter(id=>id!==target && state.active.has(id));
    if(adj.length){ const extra = adj[rand(adj.length)]; explode(extra, true); log(`Chain blast spread to ${ROOM_LIST.find(r=>r.id===extra).name}.`); }
  }

  // Check loss
  if(!state.active.has(state.player)){
    if(state.items.Vest){ state.items.Vest=false; document.querySelector('[data-item="Vest"]').classList.add('used'); log('Your Vest absorbed the blast. You stumble to an adjacent room.'); // auto-move to any alive neighbor
      const opts = neighbors(target).map(r=>r.id).filter(id=>state.active.has(id));
      if(opts.length){ state.player=opts[rand(opts.length)]; }
      else { // pick any alive room
        const alive=[...state.active]; state.player=alive[rand(alive.length)]; }
    } else { return gameOver(false); }
  }

  // Next round setup
  state.round++; state.movedThisTurn=false; refreshAll();
  if(state.active.size===1){ return gameOver(true); }
  setTurn('Your move. Stay or move to an adjacent room.'); startTimer(); }

function explode(id, silent){
  const cell=document.getElementById('cell-'+id); if(!cell) return;
  cell.classList.add('boom'); const blast=document.createElement('div'); blast.className='blast'; blast.style.setProperty('--x', (20+60*Math.random())+'%'); blast.style.setProperty('--y',(20+60*Math.random())+'%'); cell.appendChild(blast); setTimeout(()=>blast.remove(),520);
  if(!silent) { const n=ROOM_LIST.find(r=>r.id===id).name; log(`Bomb hit ${n}.`); }
  boom();
  state.active.delete(id); drawCell(id); document.getElementById('roomsLeft').textContent=state.active.size;
}

function gameOver(win){
  clearInterval(state.timer);
  if(win){ log('You survived as the last room standing.'); setTurn('You win!'); document.getElementById('timer').textContent='—'; const score=state.round; if(score>state.best){ state.best=score; localStorage.setItem('hunted_best',String(score)); } refreshAll(); }
  else { log('You were caught in the blast.'); setTurn('You lose. Press Reset to try again.'); document.getElementById('timer').textContent='—'; }
}

/*** HINTS & ITEMS ***/
function genHints(){
  // compute two suggested rooms: usually highest weights
  const entries = Object.entries(state.weights).filter(([id,_])=>state.active.has(id));
  entries.sort((a,b)=>b[1]-a[1]);
  const truthRooms = entries.slice(0,2).map(([id])=>id);
  const allAlive=[...state.active];
  const maybe = [];
  for(const id of truthRooms){ maybe.push(Math.random()<HINT_TRUTH? id : allAlive[rand(allAlive.length)]); }
  const names = maybe.map(id=>ROOM_LIST.find(r=>r.id===id).name);
  setHints(`Fresh trails near: ${names.join(' & ')}`);
}

function buildItems(){
  const wrap=document.getElementById('items');
  const item = (name, desc, fn)=>{
    const el=document.createElement('div'); el.className='item'; el.textContent=name; el.title=desc; el.dataset.item=name; el.onclick=()=>{ if(el.classList.contains('used')) return; fn(el); };
    wrap.appendChild(el);
  };
  item('Decoy','Place on a room. If bombed this round, room survives and decoy breaks.', (el)=> useDecoy(el));
  item('Scout','Reveal two most likely targets BEFORE you move this round.', (el)=> useScout(el));
  item('Dash','Move two steps this turn (second step ignores adjacency).', (el)=> useDash(el));
  item('Vest','Survive one explosion.', (el)=>{ state.items.Vest=true; el.classList.add('used'); log('You put on a protective vest.'); });
}

let decoyRoom=null; let dashed=false; let scouted=false;
function useDecoy(el){ if(decoyRoom){ log('Decoy already placed.'); return; } chooseRoom('Place Decoy on which room?', (id)=>{ if(!state.active.has(id)) return; decoyRoom=id; el.classList.add('used'); log(`Decoy placed in ${ROOM_LIST.find(r=>r.id=id).name}.`); }); }
function useScout(el){ if(scouted){ log('Scout already used this round.'); return; } // show hints immediately
  scouted=true; el.classList.add('used'); const entries = Object.entries(state.weights).filter(([id,_])=>state.active.has(id)); entries.sort((a,b)=>b[1]-a[1]); const names = entries.slice(0,2).map(([id])=>ROOM_LIST.find(r=>r.id===id).name); setHints(`Scout reports: ${names.join(' & ')}`); log('Scout used.'); }
function useDash(el){ if(dashed) return; dashed=true; el.classList.add('used'); setTurn('Dash active: click any room to relocate (ignores adjacency for this move). Then press Stay.'); const origHandler=onCellClick; onCellClick=(id)=>{ if(!state.active.has(id)) return; state.player=id; state.movedThisTurn=true; refreshAll(); setTurn(`Dashed to ${ROOM_LIST.find(r=>r.id===id).name}. Press Stay to end turn.`); onCellClick=origHandler; } }

function chooseRoom(promptText, cb){ setTurn(promptText); const origHandler=onCellClick; onCellClick=(id)=>{ cb(id); onCellClick=origHandler; setTurn('Action chosen. Finish your turn.'); } }

// Decoy effect hook: if target equals decoy, cancel destruction
const _explode=explode; explode=(id, silent)=>{
  if(decoyRoom===id){ log('Decoy absorbed the blast! Room stands.'); boom(); decoyRoom=null; return; }
  _explode(id, silent);
  decoyRoom=null; dashed=false; scouted=false; // reset per round
};

/*** AESTHETIC: optional PNGs per room ***/
// Put PNGs at /assets/<id>.png (e.g., assets/living.png). We will set them as CSS backgrounds if found.
(async function preloadPNGs(){
  for(const r of ROOM_LIST){ try{ const res=await fetch(`assets/${r.id}.png`,{method:'HEAD'}); if(res.ok){ const cell=document.getElementById('cell-'+r.id); if(cell) cell.style.backgroundImage=`url(assets/${r.id}.png)`; cell && (cell.style.backgroundSize='cover'); } }catch(_){} }
})();

/*** INIT ***/
buildGrid(); buildItems(); refreshAll(); reset();
</script>
</body>
</html>
